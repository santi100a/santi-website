this.workbox=this.workbox||{},this.workbox.strategies=function(e,t,r,s,o,a,n,i,c,h){"use strict";function l(){return l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(e[s]=r[s])}return e},l.apply(this,arguments)}try{self["workbox:strategies:6.0.2"]&&_()}catch(e){}function u(e){return"string"==typeof e?new Request(e):e}class d{constructor(e,r){this._cacheKeys={},t.assert.isInstance(r.event,ExtendableEvent,{moduleName:"workbox-strategies",className:"StrategyHandler",funcName:"constructor",paramName:"options.event"}),Object.assign(this,r),this.event=r.event,this._strategy=e,this._handlerDeferred=new i.Deferred,this._extendLifetimePromises=[],this._plugins=[...e.plugins],this._pluginStateMap=new Map;for(const e of this._plugins)this._pluginStateMap.set(e,{});this.event.waitUntil(this._handlerDeferred.promise)}fetch(e){return this.waitUntil((async()=>{const{event:t}=this;let o=u(e);if("navigate"===o.mode&&t instanceof FetchEvent&&t.preloadResponse){const e=await t.preloadResponse;if(e)return r.logger.log(`Using a preloaded navigation response for '${a.getFriendlyURL(o.url)}'`),e}const n=this.hasCallback("fetchDidFail")?o.clone():null;try{for(const e of this.iterateCallbacks("requestWillFetch"))o=await e({request:o.clone(),event:t})}catch(e){throw new s.WorkboxError("plugin-error-request-will-fetch",{thrownError:e})}const i=o.clone();try{let e;e=await fetch(o,"navigate"===o.mode?void 0:this._strategy.fetchOptions),r.logger.debug(`Network request for '${a.getFriendlyURL(o.url)}' returned a response with status '${e.status}'.`);for(const r of this.iterateCallbacks("fetchDidSucceed"))e=await r({event:t,request:i,response:e});return e}catch(e){throw r.logger.error(`Network request for '${a.getFriendlyURL(o.url)}' threw an error.`,e),n&&await this.runCallbacks("fetchDidFail",{error:e,event:t,originalRequest:n.clone(),request:i.clone()}),e}})())}async fetchAndCachePut(e){const t=await this.fetch(e),r=t.clone();return this.waitUntil(this.cachePut(e,r)),t}cacheMatch(e){return this.waitUntil((async()=>{const t=u(e);let s;const{cacheName:o,matchOptions:a}=this._strategy,n=await this.getCacheKey(t,"read"),i=l({},a,{cacheName:o});s=await caches.match(n,i),s?r.logger.debug(`Found a cached response in '${o}'.`):r.logger.debug(`No cached response found in '${o}'.`);for(const e of this.iterateCallbacks("cachedResponseWillBeUsed"))s=await e({cacheName:o,matchOptions:a,cachedResponse:s,request:n,event:this.event})||void 0;return s})())}async cachePut(e,t){const o=u(e);await h.timeout(0);const i=await this.getCacheKey(o,"write");if(i.method&&"GET"!==i.method)throw new s.WorkboxError("attempt-to-cache-non-get-request",{url:a.getFriendlyURL(i.url),method:i.method});if(!t)throw r.logger.error(`Cannot cache non-existent response for '${a.getFriendlyURL(i.url)}'.`),new s.WorkboxError("cache-put-with-no-response",{url:a.getFriendlyURL(i.url)});const l=await this._ensureResponseSafeToCache(t);if(!l)return void r.logger.debug(`Response '${a.getFriendlyURL(i.url)}' will not be cached.`,l);const{cacheName:d,matchOptions:p}=this._strategy,g=await self.caches.open(d),w=this.hasCallback("cacheDidUpdate"),m=w?await n.cacheMatchIgnoreParams(g,i.clone(),["__WB_REVISION__"],p):null;r.logger.debug(`Updating the '${d}' cache with a new Response for ${a.getFriendlyURL(i.url)}.`);try{await g.put(i,w?l.clone():l)}catch(e){throw"QuotaExceededError"===e.name&&await c.executeQuotaErrorCallbacks(),e}for(const e of this.iterateCallbacks("cacheDidUpdate"))await e({cacheName:d,oldResponse:m,newResponse:l.clone(),request:i,event:this.event})}async getCacheKey(e,t){if(!this._cacheKeys[t]){let r=e;for(const e of this.iterateCallbacks("cacheKeyWillBeUsed"))r=u(await e({mode:t,request:r,event:this.event,params:this.params}));this._cacheKeys[t]=r}return this._cacheKeys[t]}hasCallback(e){for(const t of this._strategy.plugins)if(e in t)return!0;return!1}async runCallbacks(e,t){for(const r of this.iterateCallbacks(e))await r(t)}*iterateCallbacks(e){for(const t of this._strategy.plugins)if("function"==typeof t[e]){const r=this._pluginStateMap.get(t),s=s=>{const o=l({},s,{state:r});return t[e](o)};yield s}}waitUntil(e){return this._extendLifetimePromises.push(e),e}async doneWaiting(){let e;for(;e=this._extendLifetimePromises.shift();)await e}destroy(){this._handlerDeferred.resolve()}async _ensureResponseSafeToCache(e){let t=e,s=!1;for(const e of this.iterateCallbacks("cacheWillUpdate"))if(t=await e({request:this.request,response:t,event:this.event})||void 0,s=!0,!t)break;return s||(t&&200!==t.status&&(t=void 0),t&&200!==t.status&&(0===t.status?r.logger.warn(`The response for '${this.request.url}' is an opaque response. The caching strategy that you're using will not cache opaque responses by default.`):r.logger.debug(`The response for '${this.request.url}' returned a status code of '${e.status}' and won't be cached as a result.`))),t}}class p{constructor(e={}){this.cacheName=o.cacheNames.getRuntimeName(e.cacheName),this.plugins=e.plugins||[],this.fetchOptions=e.fetchOptions,this.matchOptions=e.matchOptions}handle(e){const[t]=this.handleAll(e);return t}handleAll(e){e instanceof FetchEvent&&(e={event:e,request:e.request});const t=e.event,r="string"==typeof e.request?new Request(e.request):e.request,s="params"in e?e.params:void 0,o=new d(this,{event:t,request:r,params:s}),a=this._getResponse(o,r,t);return[a,this._awaitComplete(a,o,r,t)]}async _getResponse(e,t,o){let n;await e.runCallbacks("handlerWillStart",{event:o,request:t});try{if(n=await this._handle(t,e),!n||"error"===n.type)throw new s.WorkboxError("no-response",{url:t.url})}catch(s){for(const r of e.iterateCallbacks("handlerDidError"))if(n=await r({error:s,event:o,request:t}),n)break;if(!n)throw s;r.logger.log(`While responding to '${a.getFriendlyURL(t.url)}', an ${s} error occurred. Using a fallback response provided by a handlerDidError plugin.`)}for(const r of e.iterateCallbacks("handlerWillRespond"))n=await r({event:o,request:t,response:n});return n}async _awaitComplete(e,t,r,s){let o,a;try{o=await e}catch(a){}try{await t.runCallbacks("handlerDidRespond",{event:s,request:r,response:o}),await t.doneWaiting()}catch(e){a=e}if(await t.runCallbacks("handlerDidComplete",{event:s,request:r,response:o,error:a}),t.destroy(),a)throw a}}const g=(e,t)=>`Using ${e} to respond to '${a.getFriendlyURL(t.url)}'`,w=e=>{e&&(r.logger.groupCollapsed("View the final response here."),r.logger.log(e||"[No response returned]"),r.logger.groupEnd())},m={cacheWillUpdate:async({response:e})=>200===e.status||0===e.status?e:null};return e.CacheFirst=class extends p{async _handle(e,o){const a=[];t.assert.isInstance(e,Request,{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"makeRequest",paramName:"request"});let n,i=await o.cacheMatch(e);if(i)a.push(`Found a cached response in the '${this.cacheName}' cache.`);else{a.push(`No response found in the '${this.cacheName}' cache. Will respond with a network request.`);try{i=await o.fetchAndCachePut(e)}catch(e){n=e}i?a.push("Got response from network."):a.push("Unable to get a response from the network.")}r.logger.groupCollapsed(g(this.constructor.name,e));for(const e of a)r.logger.log(e);if(w(i),r.logger.groupEnd(),!i)throw new s.WorkboxError("no-response",{url:e.url,error:n});return i}},e.CacheOnly=class extends p{async _handle(e,o){t.assert.isInstance(e,Request,{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"makeRequest",paramName:"request"});const a=await o.cacheMatch(e);if(r.logger.groupCollapsed(g(this.constructor.name,e)),a?(r.logger.log(`Found a cached response in the '${this.cacheName}' cache.`),w(a)):r.logger.log(`No response found in the '${this.cacheName}' cache.`),r.logger.groupEnd(),!a)throw new s.WorkboxError("no-response",{url:e.url});return a}},e.NetworkFirst=class extends p{constructor(e={}){super(e),this.plugins.some((e=>"cacheWillUpdate"in e))||this.plugins.unshift(m),this._networkTimeoutSeconds=e.networkTimeoutSeconds||0,this._networkTimeoutSeconds&&t.assert.isType(this._networkTimeoutSeconds,"number",{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"constructor",paramName:"networkTimeoutSeconds"})}async _handle(e,o){const a=[];t.assert.isInstance(e,Request,{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"handle",paramName:"makeRequest"});const n=[];let i;if(this._networkTimeoutSeconds){const{id:t,promise:r}=this._getTimeoutPromise({request:e,logs:a,handler:o});i=t,n.push(r)}const c=this._getNetworkPromise({timeoutId:i,request:e,logs:a,handler:o});n.push(c);for(const e of n)o.waitUntil(e);let h=await Promise.race(n);h||(h=await c),r.logger.groupCollapsed(g(this.constructor.name,e));for(const e of a)r.logger.log(e);if(w(h),r.logger.groupEnd(),!h)throw new s.WorkboxError("no-response",{url:e.url});return h}_getTimeoutPromise({request:e,logs:t,handler:r}){let s;return{promise:new Promise((o=>{s=setTimeout((async()=>{t.push(`Timing out the network response at ${this._networkTimeoutSeconds} seconds.`),o(await r.cacheMatch(e))}),1e3*this._networkTimeoutSeconds)})),id:s}}async _getNetworkPromise({timeoutId:e,request:t,logs:r,handler:s}){let o,a;try{a=await s.fetchAndCachePut(t)}catch(e){o=e}return e&&clearTimeout(e),a?r.push("Got response from network."):r.push("Unable to get a response from the network. Will respond with a cached response."),!o&&a||(a=await s.cacheMatch(t),a?r.push(`Found a cached response in the '${this.cacheName}' cache.`):r.push(`No response found in the '${this.cacheName}' cache.`)),a}},e.NetworkOnly=class extends p{constructor(e={}){super(e),this._networkTimeoutSeconds=e.networkTimeoutSeconds||0}async _handle(e,o){let a,n;t.assert.isInstance(e,Request,{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"_handle",paramName:"request"});try{const t=[o.fetch(e)];if(this._networkTimeoutSeconds){const e=h.timeout(1e3*this._networkTimeoutSeconds);t.push(e)}if(n=await Promise.race(t),!n)throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`)}catch(e){a=e}if(r.logger.groupCollapsed(g(this.constructor.name,e)),n?r.logger.log("Got response from network."):r.logger.log("Unable to get a response from the network."),w(n),r.logger.groupEnd(),!n)throw new s.WorkboxError("no-response",{url:e.url,error:a});return n}},e.StaleWhileRevalidate=class extends p{constructor(e){super(e),this.plugins.some((e=>"cacheWillUpdate"in e))||this.plugins.unshift(m)}async _handle(e,o){const a=[];t.assert.isInstance(e,Request,{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"handle",paramName:"request"});const n=o.fetchAndCachePut(e).catch((()=>{}));let i,c=await o.cacheMatch(e);if(c)a.push(`Found a cached response in the '${this.cacheName}' cache. Will update with the network response in the background.`);else{a.push(`No response found in the '${this.cacheName}' cache. Will wait for the network response.`);try{c=await n}catch(e){i=e}}r.logger.groupCollapsed(g(this.constructor.name,e));for(const e of a)r.logger.log(e);if(w(c),r.logger.groupEnd(),!c)throw new s.WorkboxError("no-response",{url:e.url,error:i});return c}},e.Strategy=p,e.StrategyHandler=d,e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);